# Computing per-base coverage from a BAM file. Specific to MRE-seq, in scenario where camera is switched off for an offset number of bases.
# Prequisites:
# 1) BAM file sorted by read name. samtools sort -n
# 2) RE site coordinates for RE used.
#
# Make sure that output is in the correct genome build (e.g. to work with Affy tiling arrays you may need to LiftOver from mm9 to mm8 for e.g.).

bedpe2REcvg <- function(
	file, #folder,
		# folder location containing bed file that is output of bedtools bamToBed -pe 
	REfile,
		# Rdata file containing RE coordinates for genome build & chroms of interest. Generated by MREseq_saveREcoords.R
	percentagesFile="RE_percentages.txt",
		# file to print the RE percentages to
	stripSfx=".sorted.byname.bam.bed",
		# string to strip from filename before displaying as title on pie chart. 
	addOffset=3,
		#(integer) offset by which to expand coordinates of PE1 start and PE2 end. Set value to 3 for scenario where camera is off for first 3 bases. Set to 0 where camera is not off (e.g. MREseq pilot)
	testMode=F
) {

suppressMessages(require(GenomicRanges))
suppressMessages(require(Rsamtools))

options(scipen=10)

# Get *expanded.bam.bed.gz file
#tabixBedList <- dir(path=folder, pattern="*.sorted.expanded.bam.bed.gz$", full.names=T)
#if( length(tabixBedList) != 1) stop("Error: Input folder contains more than one *sorted.expanded.bam.bed.gz file.")
#else bedFile <- tabixBedList[1]
#tabixBed <- TabixFile(tabixBedList[1])
tabixBed <- TabixFile(file)
bedFile <- file

# Load RE coordinates, then split them by chromosome
load(REfile) # 1-based
RE_CG_coords_split <- sapply(names(RE_CG_coords), function(re) { return(split(RE_CG_coords[[re]], seqnames(RE_CG_coords[[re]]))) }, USE.NAMES=T)

# Get file variables, then create output folders
fileBase <- basename(bedFile)
fileFolder <- dirname(bedFile)
if( fileFolder=="." ) fileFolder <- ""
else fileFolder <- paste(fileFolder,"/",sep="")
dir.create(paste(fileFolder,"coverage",sep=""),showWarnings=F)
dir.create(paste(fileFolder,"RE_score",sep=""),showWarnings=F)

# Get list of RE chromosomes and input file chromosomes, then use only the intersection
RE_chrom <- as.vector(runValue(seqnames(RE_CG_coords[[names(RE_CG_coords)[1]]])))
input_chrom <- seqnamesTabix(tabixBed)
chromosomes <- intersect(RE_chrom, input_chrom)

# Initialize variables
REcounts <- numeric()
totread <- 0
ol_counts <- numeric()

RE_overlaps <- sapply(chromosomes, USE.NAMES=T, FUN=function(chr) {
	cat("* Working on", chr, ": reading tabix file, ")

	rawData <- scanTabix(tabixBed, param=GRanges(chr, IRanges(0, 500000000)))
	unlist <- unlist(rawData)
	if(length(unlist)==0) {
		cat("no reads were found in given range\n")
		return(c(0,0,0,0))
	}
	
	split <- strsplit(unlist, split="\t")
	dat <- data.frame("chr"=rep(chr), "start"=as.numeric(unlist(lapply(split, "[[", 2))), "end"=as.numeric(unlist(lapply(split, "[[", 3))), stringsAsFactors=F, row.names=NULL)
	#dat[,2] <- as.numeric(dat[,2]); dat[,3] <- as.numeric(dat[,3])
	
	cat("reading PE coordinates ")
	# Note: These coordinates are read in from a BED file, so they are half-open (0-based start, 1-based end)
	# This script will use 1-based coordinates throughout
	# All reference files should use 1-based coordinates as well
	
	#if (testMode) dat <- read.delim(dataConnection, sep="\t", header=F, as.is=T, nrow=1000)
	#else dat <- read.delim(dataConnection, sep="\t", header=F, as.is=T)

	cat(sprintf("(total of %i reads), ", nrow(dat)))

	cat("creating GRanges objects, ")
	# convert half-open BED start coordinate to 1-based coordinate
	dat[,2] <- dat[,2]+1

	# widen PE to cover what could have been covered if we overlapped RE sites.
	# now the + reads should theoretically now begin with a C (since they were cut at a CG...)
	# and the - reads should theoretically now end with a G (since they were cut at a ...CG)
	dat[,2] <- dat[,2]-addOffset; dat[,3] <- dat[,3]+addOffset;
	
	PE <- GRanges(dat[,1], IRanges(dat[,2],dat[,3]-1))
	
	# subtract end by one to get the C bp instead of the G bp (to match with target RE coordinates, which are all Cs)
	#PE_end <- GRanges(dat[,4], IRanges(dat[,6]-1,dat[,6]-1)) # "-" strand read aligns to C on opposite strand.

	totread <- totread + nrow(dat)

	cat("get OL with RE sites, ")
	ol_PE <- numeric()
	pctVals <- numeric()
	for (re in names(RE_CG_coords)) {
		ol_start <- as.matrix(suppressWarnings(findOverlaps(PE, RE_CG_coords_split[[re]][[chr]], type="start")))[,1]; 
		ol_end <- as.matrix(suppressWarnings(findOverlaps(PE, RE_CG_coords_split[[re]][[chr]], type="end")))[,1]; 
		ol_both <- intersect(ol_start, ol_end)
		count <- length(ol_both)
		ol_PE <- c(ol_PE, ol_both)
		ol_counts <- c(ol_counts, count)
	}
	ol_counts <- c(ol_counts, nrow(dat)-sum(ol_counts))

	# Checks to make sure that at least one overlap was actually found, and stop the function (return) if no overlaps were found
	if(length(ol_PE)==0) {
		cat("no overlaps found for ",chr,"\n", sep="")
		return(ol_counts)
	}

	dat_RE <- dat[ol_PE,]
	
	cat("computing coverage, ")
	gr <- GRanges(dat_RE[,1],IRanges(dat_RE[,2],dat_RE[,3])) # 1-base
	cvg <- coverage(gr)
	mega_df <- NULL
	x <- cvg[[chr]]
	rstart_x <- c(1,cumsum(x@lengths)+1)
	rend_x <- rstart_x-1
	df <- data.frame(chrom=chr, start=rstart_x[-length(rstart_x)], end=rend_x[-1], cvg=x@values);

	# Convert to 0-based start for bedgraph output
	df[,2] <- df[,2]-1

	cat("writing coverage file, ")
	write.table(df,file=paste(fileFolder,"coverage/",fileBase,".coverage.",chr,".bedgraph",sep=""),col=F,row=F,quote=F,sep="\t")


	cat("computing RE scores: ")
	# Write files of score counts for all RE sites, on a per-chromosome basis

	# ol_PE indexes the pairs for which both reads aligned to an RE
	# So we first obtain these GRanges objects
	PE_both <- PE[ol_PE,]

	# Output RE score files

	RE_score_df <- NULL
	for (re in names(RE_CG_coords)) {
		cat(re,", ",sep="")
		# We sub-select only the reads for this chr to be more efficient
		RE_CG_coords_currchr <- RE_CG_coords[[re]][seqnames(RE_CG_coords[[re]])==chr]

		# For each RE site on the chr, count the number of overlaps with PE reads (start or end)
		ol_RE <- suppressWarnings(countOverlaps(RE_CG_coords_split[[re]][[chr]], PE_both, type="start")) + suppressWarnings(countOverlaps(RE_CG_coords_split[[re]][[chr]], PE_both, type="end"))

		# Resize CG coords to full, 4 bp RE site
		RE_CG_coords_resized <- resize(resize(RE_CG_coords_split[[re]][[chr]], 3, fix="start"), 4, fix="end")
		
		# Convert RE coords to df, select first three columns, and creates a DF with the coordinates, score and RE site name
		# We also need to convert the start coord from 1-based to 0-based
		df <- cbind("seqnames"=as.data.frame(RE_CG_coords_resized)[,1],
					"start"=as.data.frame(RE_CG_coords_resized)[,2]-1,
					"end"=as.data.frame(RE_CG_coords_resized)[,3],
					data.frame("re_name"=rep(re), "re_score"=ol_RE ))
		if (is.null(RE_score_df)) RE_score_df <- df
		else RE_score_df <- rbind(RE_score_df, df)
	}

	# Write RE score file
	cat("writing score file, ")
	if (sum(RE_score_df[,"re_score"]) != 0) {
		write.table(RE_score_df,file=paste(fileFolder,"RE_score/",fileBase,".mre_score.",chr,".bedgraph",sep=""),col=F,row=F,quote=F,sep="\t")
	}
	
	cat("done.\n")
	return(ol_counts)
})

totread <- sum(RE_overlaps)

# Sum counts across chromosomes
counts <- apply(RE_overlaps, 1, sum)
names(counts) <- c(names(RE_CG_coords), "other")
counts <- t(counts)
row.names(counts) <- file

pctVals <- apply(RE_overlaps, 1, function(x) { round((sum(x)/totread)*100) })
pctVals[length(pctVals)] <- 100-sum(pctVals[-length(pctVals)])
names(pctVals) <- c(names(RE_CG_coords), "other")
pctVals <- t(pctVals)
row.names(pctVals) <- file

cat("Overlap counts and percentages:\n")
RE_names <- c(names(RE_CG_coords), "other")
for (i in 1:length(RE_names)) {
	cat("\t", RE_names[i], ":\t", counts[1,i], "\t", pctVals[1,i], "%\n", sep="")
}

write.table(pctVals,file=paste(fileFolder,"MREseq_PE_pcts.txt",sep=""),sep="\t",quote=F)
write.table(counts,file=paste(fileFolder,"MREseq_PE_counts.txt",sep=""),sep="\t",quote=F)

# Print RE percentages for creating a barplot
if(file.exists(percentagesFile)) write.table(pctVals, file=percentagesFile, append=T, col=F, row=T, sep="\t", quote=F)
else write.table(pctVals, file=percentagesFile, append=F, col=T, row=T, sep="\t", quote=F)

#return(pctVals)

### (No value).
### Writes bedgraphs for each chromosome of MRE coverage across the genome; columns are: 1) chrom, 2) start, 3) end, 4) score. There is no header and coordinates are half-open.
### Writes bedgraphs for each chromosome of MRE score for all RE sites; columns are: 1) chrom, 2) start, 3) end, 4) RE site 5) score. There is no header and coordinates are half-open.
### Also saves .pdf file with pie chart showing % breakdown of PE read mapping to different RE + residual.
}
